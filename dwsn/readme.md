# DWSN - 动态宽度可排序数字编码方案(Dynamic Width Sort-safe Number)

普通的数字作为**编号**，在作为字串排序的时候，容易引起错位；例如:
- 1
- 10
- 2
- 3

了解决这个问题，通常我们使用定宽数字，例如：
- 001
- 002
- 010
- 100

然而这样也有麻烦，如果一开始位数定少了（例如4位），到后来发现，至少要6位，就要变更规则；  
一但规则变更，会造成一系列的问题（比如历史上的电话号码升位，就是一个更换所有设备的大工程！）

为了保险，我们不得不一开始就规定一个比较大的位数（如12位），然而，而业务的发展没有想象的那么快，实际上可能用到8位数就到头了。。。
这样系统中就在到处使用这些永远是一串0开头的数字。。。  

文本介绍一种位数可动态扩充，且无论按数字方式、还是字符串方式排序都正常的序编码方法；

# 标准编码序列：
- 1
- 20, 21, ... , 29
- 300, 301, ... , 399
- ...
- 900'000'000 ... 999'999'999

## 编码规则：
1. 每个编号由**“首数”**和**“尾数”**两部分组成；
1. **“首数”**为一位数字（用H表示）, 必须在1-9范围内（不含0，否则解析为数字时将丢失首位0）
1. **“尾数”**有H-1位，如3开头的序号，后面跟2位数字；

## 编码特点：
1. 标准编码序列，可表达的数字范围为：
   - 10^8 + 10^7 + ... + 10 + 1 = 111,111,111 （个），通常都够用了；
1. 编号长度，从"1"开始，逐渐增加；
1. 符合此编码规则的编号，无论以数字方式排序，还是以字符串方式排序，均不会错位；

# 二阶编码序列
如果，标准编码的一亿多个编号仍不够用，可以扩展为二阶编码：
- 1                   【10^0=1个序数】
- 200 201 ... 299     【10^2=100个序数】
- 30,000 30,001 ... 39,999 【10^4=10000个数】
- ...
- 90,000,000,000,000,000 ...  99,999,999,999,999,999 【 10^16 个序数】

## 编码规则
1. **“首数”**（H），还是1-9的范围
1. **“尾数”**的位数为 2\*(H-1) 个  
这就是“二阶”一词的来由  **（标准编码，亦称为"一阶编码"）**

## 二阶编码特点
除了继承了标准编码规则的所有优点之外，扩充了编码个数(超过10^16个)

# 高阶编码
仿照二阶编码的思路，我们还可以使用三阶编码（编号个数超过10^24），四阶编码（个数超过 10^32），以及更高阶编码（个数超过 10^(N*8)）！

# 超阶编码
对于高阶编码例如（四阶），初始的编码数字比较长（2字头的已经有9位了），在某些场合下希望一开始的编号短一些；  
但是，使用低阶编码，又不能满足编号总数的要求；  
为了解决这种“变态”问题，“超阶编码”就这么轻轻的来了~~~
- 1 【10^0个数】
- 20 ... 29 【10^(0+1)=10个数】
- 3,000 ... 3,999 【10^(0+1+2)=10^3个数】
- ...
- 90...0(36个0)  ... 99...9(37个9)  【10^(0+1+2+3+ ... +8)=10^36个数】

## 编码特点
- “尾数”的位数，为0+1+2+...+(H-1);
- 一开始的一批序号（H=2、3）的时候，位数不大；
- 但总的编码个数又足够大，足够应付大多数“变态”的需求！

# 超级编码的变种
都已经“超级”了，还能怎么变？  
没有做不到的，只有想不到的！  
如果碰到了“超级变态”的需求呢?  
。。。  
我们还可以这样干！

## 自定义位数序列
1. 定义一个含9个数字的**“位数序列”**(简写为：**[S]**)：
   - **[S]** **= [ S(1), S(2), S(3), ..., S(9) ]**
1. 这里的每个S(i)表示编号的“首数”为i时，其“尾数”的位数为S(i)个;  
由此可得，“首数”为i的编号个数有 10^S(i) 个;

按照这种定义，前面讨论的编码规则，各自对应了一个“位数序列”，例如:
   - 标准编码规则：[S] = [ 0, 1, 2, ..., 8 ]
   - 二阶编码规则：[S] = [ 0, 2, 4, ..., 16 ]
   - 超级编码规则：[S] = [ 0, 1, 3, 6, 10, ..., 36 ]

于是，当为了特殊需要时，可以用**自定义 [S]**的方式来编码！ 例如：
   - [ 0,1,1,2,3,5,8,13,21 ] //斐波那契数列
   - [ 0,0,0, 0,0,0, 0,0,0 ] //整个编号集合只包含9个数（有病！呵呵）
   - [ 3,4,5, 6,7,8, 9,10,11 ] // 类似标准编码，只不过编号从1000开始...

设定各种**[S]，就“发明”出了各种自定义的编码！！！

当然，S(i)的取值还是有些限制的：
   1. S(i) >= 0 ***【虽然是废话，可也得提个醒！】***
   2. S(i+1) > S(i) ***【这不是强制的要求，但是通常如此；否则编号数量太小，没有实用价值（就像前面那个9个0的[S]!!!）】***

## 非数字编码
前面提到的都是纯数字的编号，如果用字母集合来替代数字，作为**“编码元素”**，同理可以产生类似的编码序列，并且同样可以定义“位数序列” [Sn];

示例, 大写字母(A-Z)作为编码元素的“标准编码”，  
[Sn]=[0,1,2,...,25], *注意，这里有26个位数的定义*
编码集合为：
- A
- BA, BB, ... ,BZ
- CAA, CAB, ..., CZZ
- ...
- ZA...A(25个A), ... , Z...Z(26个Z)

其中包含的编号个数 超过 26^25 > 10^35 个！
# THE END
